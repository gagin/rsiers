<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Indicator Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Let's use a simpler date input instead of React DatePicker -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- Script to detect if we're running in Docker -->
  <script>
    // Function to detect if we're running in Docker
    function isRunningInDocker() {
      // Try to detect Docker environment
      // 1. Check if we're being served from a Docker container
      if (window.location.hostname !== 'localhost') {
        // If we're not on localhost, we're likely in a Docker container
        window.IS_DOCKER = true;
        return true;
      }

      // 2. For simplicity, always use localhost for development
      // This is set as a global variable that can be used throughout the app
      window.IS_DOCKER = false;
      console.log('Running in local development environment');

      return false;
    }

    // Call the function when the page loads
    isRunningInDocker();

    // Define a function to get the backend URL
    window.getBackendUrl = function(endpoint) {
      // Always use localhost for simplicity
      return `http://localhost:5001/${endpoint}`;
    };
  </script>
</head>
<body class="bg-gray-100">
  <div id="root"></div>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.10/babel.min.js"></script>
  <script type="text/babel" data-presets="react">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [indicators, setIndicators] = useState(null);
      const [compositeMetrics, setCompositeMetrics] = useState(null);
      const [lastUpdate, setLastUpdate] = useState(null);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const viewMode = 'both'; // Always show both monthly and weekly data
      const [dataSource, setDataSource] = useState('loading'); // 'kraken', 'mock', or 'loading'
      const [timeMachineData, setTimeMachineData] = useState(null); // Historical data for time machine
      const [selectedTimePoint, setSelectedTimePoint] = useState(null); // Selected time point
      const [timeMachineActive, setTimeMachineActive] = useState(false); // Whether time machine is active
      const [selectedDate, setSelectedDate] = useState(null); // Selected date for calendar
      const [indicatorTableOpen, setIndicatorTableOpen] = useState(false); // Whether indicator table is open
      const [historicalTableOpen, setHistoricalTableOpen] = useState(false); // Whether historical table is open

      // Reference to the date picker input
      const datePickerRef = useRef(null);

      // Fetch data from our backend API or use mock data
      const fetchData = async () => {
        setLoading(true);
        setError(null);

        try {
          // Try to fetch indicator data from our backend API
          try {
            const backendUrl = window.getBackendUrl('api/indicators');
            console.log(`Fetching data from: ${backendUrl}`);
            const response = await axios.get(backendUrl);

            // Set indicators from the API response
            setIndicators(response.data.indicators);

            // Calculate composite metrics (or use from backend if provided)
            setCompositeMetrics(response.data.compositeMetrics || calculateCompositeMetrics(response.data.indicators));

            // Set last update time
            setLastUpdate(new Date(response.data.lastUpdate));

            // Set data source to Kraken
            setDataSource('kraken');

            console.log('Successfully fetched data from API');
          } catch (apiError) {
            console.error('API Error:', apiError);
            console.log('Backend unavailable. Switching to Time Machine mode with latest historical data...');

            // Make sure time machine data is loaded
            let historicalData = timeMachineData;
            if (!historicalData || historicalData.length === 0) {
              historicalData = await fetchTimeMachineData(); // This now fetches from backend /api/historical_time_points
            }

            if (historicalData && historicalData.length > 0) {
              // Find the most recent historical point
              const sortedPoints = [...historicalData].sort((a, b) =>
                new Date(b.date).getTime() - new Date(a.date).getTime()
              );

              const latestPoint = sortedPoints[0];
              console.log(`Using latest historical point: ${latestPoint.name} (${latestPoint.date})`);

              // Activate time machine with the latest point (this will set indicators/metrics from historical data)
              activateTimeMachine(latestPoint);

              // Set a message explaining what happened
              setError('Backend server unavailable. Automatically switched to Time Machine mode with the most recent historical data.');
            } else {
              console.log('No historical data available. Falling back to mock data...');

              // Fallback to mock data only if no historical data is available
              const mockData = {
                indicators: {
                  rsi: { monthly: 68, weekly: 72 },
                  stochRsi: { monthly: 75, weekly: 82 },
                  mfi: { monthly: 65, weekly: 78 },
                  crsi: { monthly: 82, weekly: 88 },
                  williamsR: { monthly: -25, weekly: -18 },
                  rvi: { monthly: 0.65, weekly: 0.72 },
                  adaptiveRsi: { monthly: 70, weekly: 75 }
                }
              };

              // Set indicators from mock data
              setIndicators(mockData.indicators);

              // Calculate composite metrics
              const metrics = calculateCompositeMetrics(mockData.indicators);
              setCompositeMetrics(metrics);

              // Set last update time
              setLastUpdate(new Date());

              // Set data source to mock
              setDataSource('mock');
            }
          }
        } catch (err) {
          setError('Failed to process data: ' + (err.message || 'Please try again.'));
          console.error('Processing Error:', err);
        } finally {
          setLoading(false);
        }
      };

      // Function to manually refresh data
      const refreshData = async () => {
        // If time machine is active, deactivate it
        if (timeMachineActive) {
          deactivateTimeMachine();
          return;
        }

        setLoading(true);
        setError(null);

        try {
          try {
            const backendUrl = window.getBackendUrl('api/refresh');
            console.log(`Refreshing data from: ${backendUrl}`);
            // Try to call the refresh endpoint
            await axios.post(backendUrl);

            // Fetch the updated data
            await fetchData();

            console.log('Data refreshed successfully');
          } catch (apiError) {
            console.error('Refresh API Error:', apiError);
            console.log('Backend unavailable for refresh. Switching to Time Machine mode with latest historical data...');

            // Make sure time machine data is loaded
            let historicalData = timeMachineData;
            if (!historicalData || historicalData.length === 0) {
              historicalData = await fetchTimeMachineData(); // This now fetches from backend /api/historical_time_points
            }

            if (historicalData && historicalData.length > 0) {
              // Find the most recent historical point
              const sortedPoints = [...historicalData].sort((a, b) =>
                new Date(b.date).getTime() - new Date(a.date).getTime()
              );

              const latestPoint = sortedPoints[0];
              console.log(`Using latest historical point for refresh: ${latestPoint.name} (${latestPoint.date})`);

              // Activate time machine with the latest point
              activateTimeMachine(latestPoint);

              // Set a message explaining what happened
              setError('Backend server unavailable. Automatically switched to Time Machine mode with the most recent historical data.');
            } else {
              console.log('No historical data available for refresh. Falling back to mock data...');

              // Fallback to mock data only if no historical data is available
              const mockData = {
                indicators: {
                  rsi: { monthly: Math.floor(Math.random() * 30) + 60, weekly: Math.floor(Math.random() * 30) + 60 },
                  stochRsi: { monthly: Math.floor(Math.random() * 30) + 60, weekly: Math.floor(Math.random() * 30) + 60 },
                  mfi: { monthly: Math.floor(Math.random() * 30) + 60, weekly: Math.floor(Math.random() * 30) + 60 },
                  crsi: { monthly: Math.floor(Math.random() * 30) + 60, weekly: Math.floor(Math.random() * 30) + 60 },
                  williamsR: { monthly: -Math.floor(Math.random() * 30) - 10, weekly: -Math.floor(Math.random() * 30) - 10 },
                  rvi: { monthly: 0.5 + Math.random() * 0.4, weekly: 0.5 + Math.random() * 0.4 },
                  adaptiveRsi: { monthly: Math.floor(Math.random() * 30) + 60, weekly: Math.floor(Math.random() * 30) + 60 }
                }
              };

              // Set indicators from mock data
              setIndicators(mockData.indicators);

              // Calculate composite metrics
              const metrics = calculateCompositeMetrics(mockData.indicators);
              setCompositeMetrics(metrics);

              // Set last update time
              setLastUpdate(new Date());

              // Set data source to mock
              setDataSource('mock');
            }
          }
        } catch (err) {
          setError('Failed to refresh data: ' + (err.message || 'Please try again.'));
          console.error('Refresh Error:', err);
        } finally {
          setLoading(false);
        }
      };

      // Function to activate time machine with a specific time point
      const activateTimeMachine = (timePoint) => {
        if (!timePoint) return;

        setSelectedTimePoint(timePoint);
        setTimeMachineActive(true);
        setSelectedDate(new Date(timePoint.date));

        // Set indicators from the selected time point
        setIndicators(timePoint.indicators);

        // Set composite metrics (should be pre-calculated in timePoint or calculated here)
        setCompositeMetrics(timePoint.compositeMetrics || calculateCompositeMetrics(timePoint.indicators));

        // Set last update time to the selected time point's date
        setLastUpdate(new Date(timePoint.date));

        // Set data source to time machine
        setDataSource('timeMachine');

        // Update the calendar input with the selected date
        if (datePickerRef.current && datePickerRef.current._flatpickr) {
          datePickerRef.current._flatpickr.setDate(new Date(timePoint.date));
        }

        console.log(`Time machine activated: ${timePoint.name} (${timePoint.date})`);
      };

      // Function to deactivate time machine
      const deactivateTimeMachine = async () => {
        setSelectedTimePoint(null);
        setTimeMachineActive(false);
        setSelectedDate(null);

        // Clear the calendar input
        if (datePickerRef.current && datePickerRef.current._flatpickr) {
          datePickerRef.current._flatpickr.clear();
        }

        // Fetch current data
        await fetchData();

        console.log('Time machine deactivated');
      };

      // NOTES: Removed fetchCurrentPrice, fetchHistoricalPrice, and estimatePriceForDate functions.
      // All price and outcome fetching logic is now handled by the backend.

      // Function to fetch data for a specific date from the backend
      const fetchDataForDate = async (date) => {
        if (!date) return;

        setLoading(true);
        setError(null);

        try {
          // Format date as ISO string (backend will parse and use Kraken)
          const dateString = date.toISOString();

          try {
            const backendUrl = window.getBackendUrl(`api/indicators?date=${dateString}`);
            console.log(`Fetching data for date ${dateString} from: ${backendUrl}`);
            const response = await axios.get(backendUrl);

            // The backend is now responsible for providing all necessary data for the time point
            const data = response.data;

            // Create a custom time point with the calculated outcomes
            const customPoint = {
              date: dateString,
              name: data.name || `Custom Date: ${date.toLocaleDateString()}`,
              price: data.price,
              description: data.description || "Custom date selected by user - data from Kraken API",
              indicators: data.indicators,
              compositeMetrics: data.compositeMetrics, // Backend should provide these
              outcomes: data.outcomes, // Backend should provide these
              isCustomDate: true  // Flag to identify this as a custom date point
            };

            // Store the custom time point
            setSelectedTimePoint(customPoint);

            // Set indicators from the selected time point
            setIndicators(customPoint.indicators);

            // Set composite metrics
            setCompositeMetrics(customPoint.compositeMetrics);

            // Set last update time
            setLastUpdate(new Date(customPoint.date));

            // Set data source to time machine
            setDataSource('timeMachine');

            // Set time machine active
            setTimeMachineActive(true);

            console.log(`Successfully fetched data for date: ${dateString}`);
          } catch (apiError) {
            console.error('API Error:', apiError);

            // If the API returns a 404, it means no data is available for this date
            if (apiError.response && apiError.response.status === 404) {
              setError(`No data available for ${date.toLocaleDateString()}: ${apiError.response.data.message || 'Please try another date.'}`);
            } else {
              setError(`Failed to fetch data for ${date.toLocaleDateString()}: ${apiError.message || 'Please try again.'}`);
            }

            // Keep the time machine active but show the error
            setTimeMachineActive(true); // Still in time machine context, just with an error
            setLoading(false); // Stop loading animation
          }
        } catch (err) {
          setError('Failed to process data: ' + (err.message || 'Please try again.'));
          console.error('Processing Error:', err);
          setLoading(false); // Stop loading animation
        }
      };


      // Fetch time machine data (pre-defined historical events)
      const fetchTimeMachineData = async () => {
        // NOTES: Now fetches from backend endpoint
        const backendUrl = window.getBackendUrl('api/historical_time_points');
        console.log(`Fetching historical time points from: ${backendUrl}`);
        return new Promise(async (resolve, reject) => {
          try {
            const response = await axios.get(backendUrl);
            const data = response.data;
            setTimeMachineData(data.timePoints);
            console.log('Time machine data loaded successfully from backend');
            resolve(data.timePoints);
          } catch (err) {
            console.error('Failed to load time machine data from backend:', err);
            // Create fallback data if backend fetch fails
            const fallbackData = [
              {
                id: 1,
                date: "2021-04-14",
                name: "2021 First Peak",
                price: 64895.00,
                description: "First peak of 2021 after institutional adoption",
                outcomes: {
                  "1M": {"direction": "down", "percentage": -35.2, "price": 42000.00},
                  "6M": {"direction": "up", "percentage": 8.9, "price": 70700.00},
                  "12M": {"direction": "down", "percentage": -39.9, "price": 39000.00}
                },
                indicators: {
                  rsi: { monthly: 88, weekly: 91 },
                  stochRsi: { monthly: 94, weekly: 96 },
                  mfi: { monthly: 89, weekly: 92 },
                  crsi: { monthly: 93, weekly: 95 },
                  williamsR: { monthly: -8, weekly: -6 },
                  rvi: { monthly: 0.87, weekly: 0.90 },
                  adaptiveRsi: { monthly: 89, weekly: 92 }
                },
                compositeMetrics: { // Include composite metrics for fallback as well
                    cos: { monthly: 110.47, weekly: 112.38 },
                    bsi: { monthly: 100, weekly: 100 }
                }
              },
              {
                id: 2,
                date: "2021-11-10",
                name: "2021 All-Time High",
                price: 69000.00,
                description: "All-time high of the 2021 bull market",
                outcomes: {
                  "1M": {"direction": "down", "percentage": -28.3, "price": 49500.00},
                  "6M": {"direction": "down", "percentage": -57.2, "price": 29500.00},
                  "12M": {"direction": "down", "percentage": -76.1, "price": 16500.00}
                },
                indicators: {
                  rsi: { monthly: 90, weekly: 93 },
                  stochRsi: { monthly: 96, weekly: 98 },
                  mfi: { monthly: 91, weekly: 94 },
                  crsi: { monthly: 95, weekly: 97 },
                  williamsR: { monthly: -7, weekly: -5 },
                  rvi: { monthly: 0.89, weekly: 0.92 },
                  adaptiveRsi: { monthly: 91, weekly: 94 }
                },
                compositeMetrics: { // Include composite metrics for fallback as well
                    cos: { monthly: 112.31, weekly: 114.22 },
                    bsi: { monthly: 100, weekly: 100 }
                }
              }
            ];
            setTimeMachineData(fallbackData);
            console.log('Using fallback historical data due to backend error.');
            resolve(fallbackData);
          }
        });
      };

      // Calculate composite metrics - This function is still here as a fallback
      // or if backend does not explicitly provide compositeMetrics for some reason.
      // It's called when 'compositeMetrics' are not present in the backend response.
      const calculateCompositeMetrics = (indicators) => {
        // Weights for Composite Overbought Score
        const weights = {
          stochRsi: 0.30,
          crsi: 0.20,
          mfi: 0.20,
          rsi: 0.15,
          williamsR: 0.10,
          rvi: 0.03,
          adaptiveRsi: 0.02
        };

        // Overbought thresholds
        const thresholds = {
          rsi: 70,
          stochRsi: 80,
          mfi: 70,
          crsi: 90,
          williamsR: -20, // Note: Williams %R is inverted
          rvi: 0.7,
          adaptiveRsi: 70
        };

        // Calculate normalized values and COS for monthly
        let monthlyNormalized = {};
        let monthlyOverbought = 0;
        Object.keys(indicators).forEach(key => {
          let value = indicators[key].monthly;
          let threshold = thresholds[key];

          // Special case for Williams %R (inverted)
          if (key === 'williamsR') {
            monthlyNormalized[key] = value <= threshold ? 100 : (Math.abs(value) / Math.abs(threshold)) * 100;
            if (value >= threshold) monthlyOverbought++;
          } else {
            monthlyNormalized[key] = (value / threshold) * 100;
            if (value >= threshold) monthlyOverbought++;
          }
        });

        // Calculate COS for monthly
        let monthlyCOS = 0;
        Object.keys(weights).forEach(key => {
          monthlyCOS += weights[key] * monthlyNormalized[key];
        });

        // Calculate normalized values and COS for weekly
        let weeklyNormalized = {};
        let weeklyOverbought = 0;
        Object.keys(indicators).forEach(key => {
          let value = indicators[key].weekly;
          let threshold = thresholds[key];

          // Special case for Williams %R (inverted)
          if (key === 'williamsR') {
            weeklyNormalized[key] = value <= threshold ? 100 : (Math.abs(value) / Math.abs(threshold)) * 100;
            if (value >= threshold) weeklyOverbought++;
          } else {
            weeklyNormalized[key] = (value / threshold) * 100;
            if (value >= threshold) weeklyOverbought++;
          }
        });

        // Calculate COS for weekly
        let weeklyCOS = 0;
        Object.keys(weights).forEach(key => {
          weeklyCOS += weights[key] * weeklyNormalized[key];
        });

        // Calculate BSI (Bull Strength Index)
        // Instead of just counting overbought indicators, we'll calculate a weighted average
        // of how far each indicator is from its neutral value (50% of threshold)
        let monthlyBSI = 0; // Renamed to BSI
        let weeklyBSI = 0;  // Renamed to BSI

        Object.keys(indicators).forEach(key => {
          const monthlyValue = indicators[key].monthly;
          const weeklyValue = indicators[key].weekly;
          const threshold = thresholds[key];

          // Calculate distance from neutral (50% of threshold)
          // For Williams %R (which is inverted), we need special handling
          if (key === 'williamsR') {
            // For Williams %R, neutral is around -50, overbought is > -20
            const neutralValue = -50;
            // Calculate how far the value is from neutral, normalized to 0-100
            const monthlyDistance = Math.min(100, Math.max(0, (neutralValue - monthlyValue) / (neutralValue - threshold) * 100));
            const weeklyDistance = Math.min(100, Math.max(0, (neutralValue - weeklyValue) / (neutralValue - threshold) * 100));

            monthlyBSI += monthlyDistance * weights[key];
            weeklyBSI += weeklyDistance * weights[key];
          } else {
            // For regular indicators, neutral is 50% of threshold
            const neutralValue = threshold * 0.5;
            // Calculate how far the value is from neutral, normalized to 0-100
            const monthlyDistance = Math.min(100, Math.max(0, (monthlyValue - neutralValue) / (threshold - neutralValue) * 100));
            const weeklyDistance = Math.min(100, Math.max(0, (weeklyValue - neutralValue) / (threshold - neutralValue) * 100));

            monthlyBSI += monthlyDistance * weights[key];
            weeklyBSI += weeklyDistance * weights[key];
          }
        });

        // Scale to 0-100%
        monthlyBSI = Math.min(100, Math.max(0, monthlyBSI));
        weeklyBSI = Math.min(100, Math.max(0, weeklyBSI));

        return {
          cos: { monthly: monthlyCOS, weekly: weeklyCOS },
          bsi: { monthly: monthlyBSI, weekly: weeklyBSI } // Renamed tsi to bsi
        };
      };

      // Get status color based on indicator value (Stable - No change)
      const getStatusColor = (indicator, value) => {
        if (indicator === 'williamsR') {
          return value >= -20 ? 'bg-red-100 text-red-800' :
                 value >= -50 ? 'bg-yellow-100 text-yellow-800' :
                 'bg-green-100 text-green-800';
        } else if (indicator === 'crsi') {
          return value >= 90 ? 'bg-red-100 text-red-800' :
                 value >= 50 ? 'bg-yellow-100 text-yellow-800' :
                 'bg-green-100 text-green-800';
        } else if (indicator === 'stochRsi') {
          return value >= 80 ? 'bg-red-100 text-red-800' :
                 value >= 50 ? 'bg-yellow-100 text-yellow-800' :
                 'bg-green-100 text-green-800';
        } else {
          return value >= 70 ? 'bg-red-100 text-red-800' :
                 value >= 50 ? 'bg-yellow-100 text-yellow-800' :
                 'bg-green-100 text-green-800';
        }
      };

      // Get tooltip text for each indicator (Stable - No change)
      const getTooltip = (indicator) => {
        const tooltips = {
          rsi: "Relative Strength Index - Overbought above 70, extreme above 80",
          stochRsi: "Stochastic RSI - Overbought above 80",
          mfi: "Money Flow Index - Overbought above 70, extreme above 80",
          crsi: "Connors RSI - Overbought above 90",
          williamsR: "Williams %R - Overbought above -20",
          rvi: "Relative Vigor Index - Overbought above 0.7",
          adaptiveRsi: "Adaptive RSI - Overbought above 70"
        };
        return tooltips[indicator] || "";
      };

      // Get detailed description for each indicator (Stable - No change)
      const getIndicatorDescription = (indicator) => {
        const descriptions = {
          rsi: "The classic momentum oscillator that measures the speed and change of price movements. RSI is the foundation of many other indicators but can lag during strong trends.",
          stochRsi: "Applies the Stochastic oscillator formula to RSI values instead of price, making it more responsive to changes in momentum. Provides earlier signals than standard RSI.",
          mfi: "Similar to RSI but incorporates volume, making it useful for confirming price movements with volume support. Helps identify divergences between price and volume.",
          crsi: "Combines three different momentum measurements (price RSI, streak RSI, and percentile rank) for a more comprehensive view of market conditions. More sensitive to short-term changes.",
          williamsR: "Identifies overbought and oversold levels with a focus on price extremes relative to recent ranges. Often leads other indicators in signaling reversals.",
          rvi: "Measures the conviction of a price movement by comparing closing prices to opening prices. Helps distinguish between strong and weak trends based on intrabar behavior.",
          adaptiveRsi: "Adjusts to market volatility, becoming more responsive during volatile periods and more stable during quiet periods. Reduces false signals in changing market conditions."
        };
        return descriptions[indicator] || "";
      };

      // Format indicator name for display (Stable - No change)
      const formatIndicatorName = (name) => {
        const names = {
          rsi: "RSI",
          stochRsi: "Stochastic RSI (%K)",
          mfi: "MFI",
          crsi: "Connors RSI",
          williamsR: "Williams %R",
          rvi: "RVI",
          adaptiveRsi: "Adaptive RSI"
        };
        return names[name] || name;
      };

      // Load data on component mount and set up interval
      useEffect(() => {
        // Create a flag to prevent multiple data fetches
        let isMounted = true;

        const loadInitialData = async () => {
          try {
            // First, fetch time machine data (pre-defined historical events)
            await fetchTimeMachineData();

            // Then, if component is still mounted, fetch current data
            if (isMounted && !timeMachineActive) {
              await fetchData();
            }
          } catch (error) {
            console.error("Error loading initial data:", error);
          }
        };

        // Load initial data
        loadInitialData();

        // Set up interval for refreshing data every 5 minutes
        const interval = setInterval(() => {
          // Only refresh if time machine is not active
          if (!timeMachineActive) {
            fetchData();
          }
        }, 5 * 60 * 1000);

        // Clean up interval and set mounted flag to false on component unmount
        return () => {
          clearInterval(interval);
          isMounted = false;
        };
      }, []);

      // Initialize Flatpickr date picker
      useEffect(() => {
        if (datePickerRef.current) {
          // Initialize Flatpickr
          const fp = flatpickr(datePickerRef.current, {
            dateFormat: "Y-m-d",
            maxDate: "today",
            minDate: "2010-07-17", // Bitcoin's first recorded price
            onChange: function(selectedDates, dateStr) {
              if (selectedDates.length > 0) {
                const date = selectedDates[0];
                console.log("Date selected:", date, dateStr);
                setSelectedDate(date);

                // For the time machine, we'll now fetch all data (indicators, price, outcomes) from backend
                // This means backend will handle finding closest historical data or fetching from Kraken.
                console.log("Fetching data for custom date:", dateStr);
                fetchDataForDate(date);
              }
            }
          });

          // Clean up Flatpickr on component unmount
          return () => {
            fp.destroy();
          };
        }
      }, [datePickerRef, timeMachineData]); // Re-run effect if timeMachineData changes (initial load)

      return (
        // NOTES: Wrapped top-level JSX elements in a React Fragment.
        <>
          <div className="container mx-auto px-4 py-8">

            <header className="mb-8">
              <div className="flex justify-between items-center">
                <h1 className="text-3xl font-bold text-gray-800">Bitcoin Indicator Dashboard <span className="text-sm font-normal text-gray-500">v0.2.0</span></h1>
                {dataSource === 'mock' || (dataSource === 'timeMachine' && error && error.includes('Backend server unavailable')) ? (
                  <button
                    onClick={fetchData}
                    className="flex items-center px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                    disabled={loading}
                  >
                    <span className="mr-2 text-lg" role="img" aria-label="red light">🔴</span>
                    {loading ? 'Retrying...' : 'Backend unavailable, retry'}
                  </button>
                ) : (
                  <button
                    onClick={refreshData}
                    className={`px-4 py-2 ${timeMachineActive ? 'bg-amber-600' : 'bg-green-600'} text-white rounded`}
                    disabled={loading}
                  >
                    {loading ? 'Refreshing...' : timeMachineActive ? 'Exit Time Machine' : 'Refresh Data'}
                  </button>
                )}
              </div>
            </header>

            {/* Time Machine UI */}
            {timeMachineData && (
                <div className="bg-white p-4 rounded-lg shadow">
                  <div className="mb-4">
                    {/* Time Machine Header with Calendar and Status */}
                    <div className="flex flex-wrap items-center justify-between gap-3 p-2 bg-gray-50 rounded">
                      <div className="flex flex-wrap items-center gap-3">
                        <h3 className="text-lg font-medium text-gray-900 mr-2">
                          <span role="img" aria-label="time machine">⏰</span> Bitcoin Time Machine
                        </h3>

                        {/* Calendar Control */}
                        <div className="flex items-center">
                          <div className="text-sm font-medium text-gray-700 mr-2">Date:</div>
                          <div className="relative">
                            <input
                              ref={datePickerRef}
                              type="text"
                              placeholder="Select a date"
                              className="px-2 py-1 border border-gray-300 rounded text-sm"
                            />
                          </div>
                        </div>
                      </div>

                      {/* Toggle button for historical table */}
                      <button
                        onClick={() => setHistoricalTableOpen(!historicalTableOpen)}
                        className="px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded text-sm font-medium text-gray-700"
                      >
                        {historicalTableOpen ? 'Hide Historical Events' : 'Show Historical Events'}
                      </button>

                      {/* Status Badge */}
                      {timeMachineActive && (
                        <span className={`text-xs font-medium px-2.5 py-0.5 rounded bg-purple-100 text-purple-800 ml-auto`}>
                          {selectedTimePoint ?
                            `Viewing: ${selectedTimePoint.name} (${new Date(selectedTimePoint.date).toLocaleDateString()})` :
                            `Viewing: Custom Date (${selectedDate ? new Date(selectedDate).toLocaleDateString() : 'Unknown'})`
                          }
                        </span>
                      )}
                    </div>

                    {!timeMachineActive && compositeMetrics ? (
                      <div className="bg-blue-50 p-2 rounded text-sm flex flex-wrap items-center justify-between">
                        <div className="font-medium text-blue-800">Current Metrics:</div>
                        <div className="flex space-x-4">
                          <div>
                            <span className="text-gray-600">
                              COS Monthly/Weekly:
                              <span className="ml-1 text-gray-400 cursor-help" title="Composite Overbought Score - Combines all indicators with weighted importance. Values above 75 suggest extreme overbought conditions.">ⓘ</span>
                            </span>
                            <span className={compositeMetrics.cos.monthly > 75 || compositeMetrics.cos.weekly > 75 ? 'ml-1 font-medium text-red-600' : 'ml-1 font-medium text-blue-600'}>
                              {compositeMetrics.cos.monthly.toFixed(1)} / {compositeMetrics.cos.weekly.toFixed(1)}
                            </span>
                            {compositeMetrics.cos.monthly > 90 || compositeMetrics.cos.weekly > 90 ?
                              <span className="ml-1 text-red-500">⚠️</span> :
                              null}
                          </div>
                          <div>
                            <span className="text-gray-600">
                              BSI Monthly/Weekly:
                              <span className="ml-1 text-gray-400 cursor-help" title="Bull Strength Index - Measures the strength of the bullish trend. Values above 75% indicate a strong bullish trend, 50-75% a moderate trend, and below 50% a weak or bearish trend.">ⓘ</span>
                            </span>
                            <span className={compositeMetrics.bsi.monthly > 50 || compositeMetrics.bsi.weekly > 50 ? 'ml-1 font-medium text-red-600' : 'ml-1 font-medium text-blue-600'}>
                              {compositeMetrics.bsi.monthly.toFixed(0)}% / {compositeMetrics.bsi.weekly.toFixed(0)}%
                            </span>
                            {compositeMetrics.bsi.monthly > 75 || compositeMetrics.bsi.weekly > 75 ?
                              <span className="ml-1 text-red-500">⚠️</span> :
                              null}
                          </div>
                        </div>
                        <div className="text-xs text-gray-500">
                          Compare current metrics with historical events below
                        </div>
                      </div>
                    ) : null}
                  </div>

                  {/* Historical events table - conditionally rendered */}
                  {historicalTableOpen ? (
                    <div className="overflow-x-auto">
                      <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-50">
                          <tr>
                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Event</th>
                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Price</th>
                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                              COS (M/W)
                              <span className="ml-1 text-gray-400 cursor-help" title="Composite Overbought Score - Combines all indicators with weighted importance. Values above 75 suggest extreme overbought conditions.">ⓘ</span>
                            </th>
                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                              BSI (M/W)
                              <span className="ml-1 text-gray-400 cursor-help" title="Bull Strength Index - Measures the strength of the bullish trend. Values above 75% indicate a strong bullish trend, 50-75% a moderate trend, and below 50% a weak or bearish trend.">ⓘ</span>
                            </th>
                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">1M Later</th>
                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">6M Later</th>
                            <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Action</th>
                          </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                          {timeMachineData.map(timePoint => (
                            <tr key={timePoint.id} className={selectedTimePoint && selectedTimePoint.id === timePoint.id ? 'bg-purple-50' : ''}>
                              <td className="px-3 py-2 whitespace-nowrap text-sm text-gray-900">{new Date(timePoint.date).toLocaleDateString()}</td>
                              <td className="px-3 py-2 text-sm font-medium text-gray-900">
                                {timePoint.name}
                                <div className="text-xs text-gray-500 break-normal">{timePoint.description}</div>
                              </td>
                              <td className="px-3 py-2 whitespace-nowrap text-sm text-gray-900">${timePoint.price ? timePoint.price.toLocaleString() : 'N/A'}</td>
                              <td className="px-3 py-2 whitespace-nowrap text-sm">
                                <span className={timePoint.compositeMetrics.cos.monthly > 75 ? 'text-red-600 font-medium' : 'text-gray-900'}>
                                  {timePoint.compositeMetrics.cos.monthly.toFixed(1)}
                                </span>
                                {' / '}
                                <span className={timePoint.compositeMetrics.cos.weekly > 75 ? 'text-red-600 font-medium' : 'text-gray-900'}>
                                  {timePoint.compositeMetrics.cos.weekly.toFixed(1)}
                                </span>
                                {timePoint.compositeMetrics.cos.monthly > 90 || timePoint.compositeMetrics.cos.weekly > 90 ?
                                  <span className="ml-1 text-red-500">⚠️</span> :
                                  null}
                              </td>
                              <td className="px-3 py-2 whitespace-nowrap text-sm">
                                <span className={timePoint.compositeMetrics.bsi.monthly > 50 ? 'text-red-600 font-medium' : 'text-gray-900'}>
                                  {timePoint.compositeMetrics.bsi.monthly.toFixed(0)}%
                                </span>
                                {' / '}
                                <span className={timePoint.compositeMetrics.bsi.weekly > 50 ? 'text-red-600 font-medium' : 'text-gray-900'}>
                                  {timePoint.compositeMetrics.bsi.weekly.toFixed(0)}%
                                </span>
                                {timePoint.compositeMetrics.bsi.monthly > 75 || timePoint.compositeMetrics.bsi.weekly > 75 ?
                                  <span className="ml-1 text-red-500">⚠️</span> :
                                  null}
                              </td>
                              <td className="px-3 py-2 whitespace-nowrap text-sm">
                                {timePoint.outcomes['1M'].direction !== 'unknown' ? (
                                  <span className={timePoint.outcomes['1M'].direction === 'up' ? 'text-green-600' : 'text-red-600'}>
                                    {timePoint.outcomes['1M'].direction === 'up' ? '↑' : '↓'} {timePoint.outcomes['1M'].percentage}%
                                  </span>
                                ) : (
                                  <span className="text-gray-500 italic">N/A</span>
                                )}
                              </td>
                              <td className="px-3 py-2 whitespace-nowrap text-sm">
                                {timePoint.outcomes['6M'].direction !== 'unknown' ? (
                                  <span className={timePoint.outcomes['6M'].direction === 'up' ? 'text-green-600' : 'text-red-600'}>
                                    {timePoint.outcomes['6M'].direction === 'up' ? '↑' : '↓'} {timePoint.outcomes['6M'].percentage}%
                                  </span>
                                ) : (
                                  <span className="text-gray-500 italic">N/A</span>
                                )}
                              </td>
                              <td className="px-3 py-2 whitespace-nowrap text-sm">
                                <button
                                  onClick={() => activateTimeMachine(timePoint)}
                                  className="text-purple-600 hover:text-purple-900"
                                >
                                  {selectedTimePoint && selectedTimePoint.id === timePoint.id ? 'Viewing' : 'View Indicators'}
                                </button>
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  ) : (
                    <div className="text-center py-4 text-sm text-gray-500 bg-gray-50 rounded">
                      Click "Show Historical Events" to view significant Bitcoin market events from 2011 to 2024.
                    </div>
                  )}

                  {selectedTimePoint && (
                    <div className="mt-4 p-3 bg-gray-50 rounded text-sm">
                      <p className="font-medium mb-2">{selectedTimePoint.description}</p>
                      <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-2 text-xs">
                        <div className="p-2 bg-white rounded shadow-sm">
                          <div className="font-medium mb-1">Price at Event</div>
                          <div className="text-lg">${selectedTimePoint.price ? selectedTimePoint.price.toLocaleString() : 'Unknown'}</div>
                        </div>

                        <div className="p-2 bg-blue-50 rounded shadow-sm">
                          <div className="font-medium mb-1">COS Monthly/Weekly</div>
                          <div className="text-lg text-blue-600">
                            {selectedTimePoint.compositeMetrics.cos.monthly.toFixed(1)} / {selectedTimePoint.compositeMetrics.cos.weekly.toFixed(1)}
                          </div>
                          <div className="text-xs text-gray-500">
                            {selectedTimePoint.compositeMetrics.cos.monthly > 75 || selectedTimePoint.compositeMetrics.cos.weekly > 75 ?
                              'Extreme overbought' : 'Normal range'}
                          </div>
                        </div>

                        <div className="p-2 bg-blue-50 rounded shadow-sm">
                          <div className="font-medium mb-1">BSI Monthly/Weekly</div>
                          <div className="text-lg text-blue-600">
                            {selectedTimePoint.compositeMetrics.bsi.monthly.toFixed(0)}% / {selectedTimePoint.compositeMetrics.bsi.weekly.toFixed(0)}%
                          </div>
                          <div className="text-xs text-gray-500">
                            {selectedTimePoint.compositeMetrics.bsi.monthly > 75 || selectedTimePoint.compositeMetrics.bsi.weekly > 75 ?
                              'Strong bullish trend' :
                              selectedTimePoint.compositeMetrics.bsi.monthly > 50 || selectedTimePoint.compositeMetrics.bsi.weekly > 50 ?
                              'Moderate bullish trend' : 'Weak or bearish trend'}
                          </div>
                        </div>

                        <div className={`p-2 rounded shadow-sm ${
                          selectedTimePoint.outcomes['1M'].direction === 'up' ? 'bg-green-50' :
                          selectedTimePoint.outcomes['1M'].direction === 'down' ? 'bg-red-50' :
                          'bg-gray-50'
                        }`}>
                          <div className="font-medium mb-1">1 Month Later</div>
                          {selectedTimePoint.outcomes['1M'].direction !== 'unknown' ? (
                            <div>
                              <div className="text-lg">
                                <span className={selectedTimePoint.outcomes['1M'].direction === 'up' ? 'text-green-600' : 'text-red-600'}>
                                  {selectedTimePoint.outcomes['1M'].direction === 'up' ? '↑' : '↓'} {selectedTimePoint.outcomes['1M'].percentage}%
                                </span>
                              </div>
                              <div>${selectedTimePoint.outcomes['1M'].price.toLocaleString()}</div>
                            </div>
                          ) : (
                            <div className="text-gray-500 italic">Not enough time has passed</div>
                          )}
                        </div>

                        <div className={`p-2 rounded shadow-sm ${
                          selectedTimePoint.outcomes['6M'].direction === 'up' ? 'bg-green-50' :
                          selectedTimePoint.outcomes['6M'].direction === 'down' ? 'bg-red-50' :
                          'bg-gray-50'
                        }`}>
                          <div className="font-medium mb-1">6 Months Later</div>
                          {selectedTimePoint.outcomes['6M'].direction !== 'unknown' ? (
                            <div>
                              <div className="text-lg">
                                <span className={selectedTimePoint.outcomes['6M'].direction === 'up' ? 'text-green-600' : 'text-red-600'}>
                                  {selectedTimePoint.outcomes['6M'].direction === 'up' ? '↑' : '↓'} {selectedTimePoint.outcomes['6M'].percentage}%
                                </span>
                              </div>
                              <div>${selectedTimePoint.outcomes['6M'].price.toLocaleString()}</div>
                            </div>
                          ) : (
                            <div className="text-gray-500 italic">Not enough time has passed</div>
                          )}
                        </div>

                        <div className={`p-2 rounded shadow-sm ${
                          selectedTimePoint.outcomes['12M'].direction === 'up' ? 'bg-green-50' :
                          selectedTimePoint.outcomes['12M'].direction === 'down' ? 'bg-red-50' :
                          'bg-gray-50'
                        }`}>
                          <div className="font-medium mb-1">12 Months Later</div>
                          {selectedTimePoint.outcomes['12M'].direction !== 'unknown' ? (
                            <div>
                              <div className="text-lg">
                                <span className={selectedTimePoint.outcomes['12M'].direction === 'up' ? 'text-green-600' : 'text-red-600'}>
                                  {selectedTimePoint.outcomes['12M'].direction === 'up' ? '↑' : '↓'} {selectedTimePoint.outcomes['12M'].percentage}%
                                </span>
                              </div>
                              <div>${selectedTimePoint.outcomes['12M'].price.toLocaleString()}</div>
                            </div>
                          ) : (
                            <div className="text-gray-500 italic">Not enough time has passed</div>
                          )}
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>

            <div className={`bg-red-100 text-red-800 p-4 rounded mb-6 ${error ? '' : 'hidden'}`}>
              {error}
            </div>

            {/* Technical Analysis Explanation */}
            <div className="bg-white p-4 rounded-lg shadow mb-6">
              <p className="text-gray-700 mb-4">
                Technical analysis is a kind of astrology, where people draw lines and waves to see patterns in the sky.
                Yet, the principle of price following the mood of the market is surprisingly solid, and RSI works quite well,
                reliably correlating with peak events. RSI has problems like lag and lack of normalization,
                so we use a bucket of other RSI-like indicators to compensate for its shortcomings while maintaining the illusion of precision.
              </p>
            </div>

            {loading && !indicators ? (
              <div className="text-center py-8">
                <p className="text-gray-600">Loading indicator data...</p>
              </div>
            ) : indicators ? (
              <div className="bg-white rounded-lg shadow overflow-hidden">
                <div className="p-4 flex justify-between items-center border-b border-gray-200">
                  <h3 className="text-lg font-medium text-gray-900">Technical Indicators</h3>
                  <button
                    onClick={() => setIndicatorTableOpen(!indicatorTableOpen)}
                    className="px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded text-sm font-medium text-gray-700"
                  >
                    {indicatorTableOpen ? 'Hide Details' : 'Show Details'}
                  </button>
                </div>

                {indicatorTableOpen && (
                  <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                      <tr>
                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Indicator
                        </th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Monthly Value
                        </th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Weekly Value
                        </th>
                        <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Status
                        </th>
                      </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                      {Object.keys(indicators).map(indicator => (
                        <tr key={indicator}>
                          <td className="px-6 py-4">
                            <div className="flex flex-col">
                              <div className="flex items-center">
                                <div className="text-sm font-medium text-gray-900">
                                  {formatIndicatorName(indicator)}
                                </div>
                                <div className="ml-2 text-gray-400 cursor-help" title={getTooltip(indicator)}>
                                  ⓘ
                                </div>
                              </div>
                              <div className="text-xs text-gray-500 mt-1 max-w-md">
                                {getIndicatorDescription(indicator)}
                              </div>
                            </div>
                          </td>

                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="text-sm text-gray-900">
                              {indicator === 'williamsR' ? indicators[indicator].monthly.toFixed(2) :
                               indicator === 'rvi' ? indicators[indicator].monthly.toFixed(2) :
                               indicators[indicator].monthly.toFixed(0)}
                            </div>
                          </td>

                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="text-sm text-gray-900">
                              {indicator === 'williamsR' ? indicators[indicator].weekly.toFixed(2) :
                               indicator === 'rvi' ? indicators[indicator].weekly.toFixed(2) :
                               indicators[indicator].weekly.toFixed(0)}
                            </div>
                          </td>

                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="flex flex-col space-y-1">
                              <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                getStatusColor(indicator, indicators[indicator].monthly)
                              }`}>
                                M: {indicators[indicator].monthly >= (indicator === 'williamsR' ? -20 :
                                                                  indicator === 'crsi' ? 90 :
                                                                  indicator === 'stochRsi' ? 80 : 70) ? 'Overbought' : 'Normal'}
                              </span>
                              <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                                getStatusColor(indicator, indicators[indicator].weekly)
                              }`}>
                                W: {indicators[indicator].weekly >= (indicator === 'williamsR' ? -20 :
                                                                 indicator === 'crsi' ? 90 :
                                                                 indicator === 'stochRsi' ? 80 : 70) ? 'Overbought' : 'Normal'}
                              </span>
                            </div>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                )}
              </div>
            ) : null}

            {compositeMetrics && (
              <div className="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="bg-white p-6 rounded-lg shadow">
                  <h3 className="text-lg font-medium text-gray-900 mb-4">
                    Composite Overbought Score (COS)
                    <span className="ml-2 text-gray-400 cursor-help" title="Composite Overbought Score - Combines all indicators with weighted importance. Values above 75 suggest extreme overbought conditions.">ⓘ</span>
                  </h3>
                  <div className="relative pt-1">
                    <React.Fragment>
                      <div className="flex mb-2 items-center justify-between">
                        <div>
                          <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200">
                            Monthly
                          </span>
                        </div>
                        <div className="text-right">
                          <span className="text-xs font-semibold inline-block text-blue-600">
                            {compositeMetrics.cos.monthly.toFixed(1)}
                          </span>
                        </div>
                      </div>
                      <div className="overflow-hidden h-2 mb-2 text-xs flex rounded bg-gray-200">
                        <div
                          style={{
                            width: `${Math.min(100, compositeMetrics.cos.monthly)}%`
                          }}
                          className={`shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center ${
                            compositeMetrics.cos.monthly > 75
                              ? 'bg-red-500'
                              : compositeMetrics.cos.monthly > 50
                                ? 'bg-yellow-500'
                                : 'bg-green-500'
                          }`}
                        ></div>
                      </div>
                      <div className="flex mb-2 items-center justify-between mt-3">
                        <div>
                          <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200">
                            Weekly
                          </span>
                        </div>
                        <div className="text-right">
                          <span className="text-xs font-semibold inline-block text-blue-600">
                            {compositeMetrics.cos.weekly.toFixed(1)}
                          </span>
                        </div>
                      </div>
                      <div className="overflow-hidden h-2 mb-4 text-xs flex rounded bg-gray-200">
                        <div
                          style={{
                            width: `${Math.min(100, compositeMetrics.cos.weekly)}%`
                          }}
                          className={`shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center ${
                            compositeMetrics.cos.weekly > 75
                              ? 'bg-red-500'
                              : compositeMetrics.cos.weekly > 50
                                ? 'bg-yellow-500'
                                : 'bg-green-500'
                          }`}
                        ></div>
                      </div>
                    </React.Fragment>
                    <p className="text-sm text-gray-600">
                      COS combines all indicators with weighted importance. Values above 75 suggest extreme overbought conditions.
                    </p>
                  </div>
                </div>

                <div className="bg-white p-6 rounded-lg shadow">
                  <h3 className="text-lg font-medium text-gray-900 mb-4">
                    Bull Strength Index (BSI)
                    <span className="ml-2 text-gray-400 cursor-help" title="Bull Strength Index - Measures the strength of the bullish trend. Values above 75% indicate a strong bullish trend, 50-75% a moderate trend, and below 50% a weak or bearish trend.">ⓘ</span>
                  </h3>
                  <div className="relative pt-1">
                    <React.Fragment>
                      <div className="flex mb-2 items-center justify-between">
                        <div>
                          <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200">
                            Monthly
                          </span>
                        </div>
                        <div className="text-right">
                          <span className="text-xs font-semibold inline-block text-blue-600">
                            {compositeMetrics.bsi.monthly.toFixed(1) + '%'}
                          </span>
                        </div>
                      </div>
                      <div className="overflow-hidden h-2 mb-2 text-xs flex rounded bg-gray-200">
                        <div
                          style={{
                            width: `${Math.min(100, compositeMetrics.bsi.monthly)}%`
                          }}
                          className={`shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center ${
                            compositeMetrics.bsi.monthly > 75
                              ? 'bg-red-500'
                              : compositeMetrics.bsi.monthly > 50
                                ? 'bg-yellow-500'
                                : 'bg-green-500'
                          }`}
                        ></div>
                      </div>
                      <div className="flex mb-2 items-center justify-between mt-3">
                        <div>
                          <span className="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200">
                            Weekly
                          </span>
                        </div>
                        <div className="text-right">
                          <span className="text-xs font-semibold inline-block text-blue-600">
                            {compositeMetrics.bsi.weekly.toFixed(1) + '%'}
                          </span>
                        </div>
                      </div>
                      <div className="overflow-hidden h-2 mb-4 text-xs flex rounded bg-gray-200">
                        <div
                          style={{
                            width: `${Math.min(100, compositeMetrics.bsi.weekly)}%`
                          }}
                          className={`shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center ${
                            compositeMetrics.bsi.weekly > 75
                              ? 'bg-red-500'
                              : compositeMetrics.bsi.weekly > 50
                                ? 'bg-yellow-500'
                                : 'bg-green-500'
                          }`}
                        ></div>
                      </div>
                    </React.Fragment>
                    <p className="text-sm text-gray-600">
                      BSI measures the strength of the bullish trend. Values above 75% indicate a strong bullish trend,
                      50-75% a moderate trend, and below 50% a weak or bearish trend.
                    </p>
                  </div>
                </div>
              </div>
            )}

            <footer className="mt-12 text-center text-sm">
              <div className="mb-2">
                {dataSource === 'timeMachine' ? (
                  <p className="text-purple-600">
                    <span className="bg-purple-100 text-purple-800 text-xs font-medium px-2.5 py-0.5 rounded">Time Machine Active</span>
                    <span className="ml-2">Viewing historical data from {lastUpdate ? lastUpdate.toLocaleDateString() : 'unknown date'}</span>
                    <span className="ml-2 bg-purple-100 text-purple-800 text-xs font-medium px-2.5 py-0.5 rounded">
                      {selectedTimePoint && selectedTimePoint.id ? 'Historical Data from JSON (via Backend)' :
                       selectedTimePoint && selectedTimePoint.isCustomDate ? 'Historical Data from Backend (Kraken API)' :
                       'Historical Data'}
                    </span>
                  </p>
                ) : dataSource === 'kraken' ? (
                  <p className="text-gray-600">
                    Data refreshes automatically every 5 minutes. Last refresh: {lastUpdate ? lastUpdate.toLocaleString() : 'Loading...'}
                    <span className="ml-2 bg-green-100 text-green-800 text-xs font-medium px-2.5 py-0.5 rounded">Live Kraken Data (via Backend)</span>
                  </p>
                ) : dataSource === 'mock' ? (
                  <p className="text-amber-600">
                    <span className="bg-amber-100 text-amber-800 text-xs font-medium px-2.5 py-0.5 rounded">Mock Data</span>
                    <span className="ml-2">Using simulated data (backend or historical data unavailable)</span>
                  </p>
                ) : (
                  <p className="text-gray-600">Loading data source...</p>
                )}
              </div>
              <p className="mt-2 text-gray-600">
                <a href="https://docs.kraken.com/rest/" className="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">
                  Kraken API Documentation
                </a>
                {' | '}
                <a href="https://www.investopedia.com/terms/r/rsi.asp" className="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">
                  Learn about RSI
                </a>
                <span className={timeMachineActive && !(error && error.includes('Backend server unavailable')) ? '' : 'hidden'}>
                  {' | '}
                  <button
                    onClick={deactivateTimeMachine}
                    className="text-purple-600 hover:underline"
                  >
                    Exit Time Machine
                  </button>
                </span>
                <span className="ml-2 text-gray-400">v0.2.0</span>
              </p>
              <p className={`mt-2 text-xs text-gray-500 ${timeMachineActive ? '' : 'hidden'}`}>
                Time Machine allows you to view indicator values at any historical date.
                Use the calendar control to select a specific date or click on a historical event in the table.
                <span className={selectedTimePoint && selectedTimePoint.id ? '' : 'hidden'}>
                  Currently viewing historical event: {selectedTimePoint ? selectedTimePoint.name : ''} with pre-calculated data from JSON (served by backend).
                </span>
                <span className={selectedTimePoint && selectedTimePoint.isCustomDate ? '' : 'hidden'}>
                  Currently viewing custom date: {selectedDate ? new Date(selectedDate).toLocaleDateString() : ''} with data fetched from Kraken API (via backend).
                </span>
                <br />
                <span className="font-medium mt-1 inline-block">Data Sources:</span> Historical events use pre-calculated data from `historical_data.json` (served by backend).
                Custom dates are fetched and calculated on the backend using Kraken API.
              </p>
            </footer>
        </>
      );
    }

    // No longer need technical indicator calculation functions as they're handled by the backend

    // Render the React app
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
</file>